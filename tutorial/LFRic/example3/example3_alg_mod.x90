! -----------------------------------------------------------------------------
! BSD 3-Clause License
!
! Copyright (c) 2020, Science and Technology Facilities Council.
! All rights reserved.
!
! Redistribution and use in source and binary forms, with or without
! modification, are permitted provided that the following conditions are met:
!
! * Redistributions of source code must retain the above copyright notice, this
!   list of conditions and the following disclaimer.
!
! * Redistributions in binary form must reproduce the above copyright notice,
!   this list of conditions and the following disclaimer in the documentation
!   and/or other materials provided with the distribution.
!
! * Neither the name of the copyright holder nor the names of its
!   contributors may be used to endorse or promote products derived from
!   this software without specific prior written permission.
!
! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
! "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
! FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
! COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
! INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
! BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
! LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
! ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
! POSSIBILITY OF SUCH DAMAGE.
! -----------------------------------------------------------------------------
! Author: I. Kavcic, Met Office
!
! -----------------------------------------------------------------------------
! Calls kernels to initialise a perturbation field on W3 space to analytical
! formula and to propagate perturbation signal in time
! -----------------------------------------------------------------------------
module example3_alg_mod

  ! Infrastructure
  use constants_mod, only : i_def, r_def
  use log_mod,       only : log_event, &
                            LOG_LEVEL_INFO
  use mesh_mod,      only : mesh_type
  use field_mod,     only : field_type

  ! Algorithms
  use diagnostic_alg_mod, only : diagnostic_coordinates_alg, &
                                 write_diagnostic_alg

  implicit none

  private

  type(field_type) :: chi_map(3)

  public :: example3_alg_init
  public :: example3_alg_step

contains

  !> @brief Initalise a perturbation field using mesh and coordinate data
  !> @param[in] mesh Partitioned 3D mesh object
  !> @param[in] chi Coordinate fields on Wchi space
  !> @param[in] perturbation Perturbation field to initialise
  subroutine example3_alg_init(mesh, chi, perturbation)

    use init_perturbation_kernel_mod, only : init_perturbation_kernel_type

    implicit none

    type(mesh_type),  intent(in)    :: mesh
    type(field_type), intent(in)    :: chi(3)
    type(field_type), intent(inout) :: perturbation

    integer(i_def)   :: i

    call log_event( "example3_alg_init: Initialising perturbation field", &
                    LOG_LEVEL_INFO )
    !---------------------------------------------------------------------------
    ! TO COMPLETE (in the same invoke):
    ! - Use built-ins to set 'perturbation' to 0
    ! - Call kernel 'init_perturbation_kernel_mod.f90` to set the perturbation
    !   field to initial condition:
    !   perturbation = ampl(z)* exp( -((x - x_centre)/half_width_x)**2 &
    !                                -((y - y_centre)/half_width_y)**2 )
    !   where ampl(z) = max(perturbation_height - z, 0)/perturbation_scale
    call invoke( name = "Initialise perturbation",  &
                 setval_c(perturbation, 0.0_r_def), &
                 init_perturbation_kernel_type(perturbation, chi) )
    !---------------------------------------------------------------------------

    !---------------------------------------------------------------------------
    ! TO COMPLETE: Check the min/max values of coordinate and perturbation
    ! fields using 'log_minmax' function
    do i = 1, size(chi)
      call chi(i)%log_minmax(LOG_LEVEL_INFO, chi(i)%name)
    end do
    call perturbation%log_minmax(LOG_LEVEL_INFO, perturbation%name)
    !---------------------------------------------------------------------------

    ! Map coordinates to perturbation space
    call diagnostic_coordinates_alg(chi, perturbation, chi_map)
    ! Output coordinate and initial perturbation fields at the initial
    ! timestep (0)
    call write_diagnostic_alg(chi_map, perturbation, 0_i_def)

  end subroutine example3_alg_init

  !> @brief Propagate a perturbation field using coordinate data and
  !!        timestepping namelist parameters
  !> @param[in] chi Coordinate fields on Wchi space
  !> @param[in] perturbation Perturbation field to propagate
  subroutine example3_alg_step(chi, perturbation)

    use timestepping_config_mod,      only : dt, timestep_start, timestep_end
    use prop_perturbation_kernel_mod, only : prop_perturbation_kernel_type

    implicit none

    type(field_type), intent(in)    :: chi(3)
    type(field_type), intent(inout) :: perturbation

    integer(i_def) :: i
    real(r_def)    :: t_tot

    call log_event( "example3_alg_step: Propagating perturbation field", &
                    LOG_LEVEL_INFO )
    !---------------------------------------------------------------------------
    ! TO COMPLETE: Propagate the perturbation field in a loop over timesteps
    ! - Calculate total propagating 't_tot' from timestep and dt
    ! - Create 'prop_perturbation_kernel_mod.f90' that propagates the field as
    !   perturbation = ampl(z)* &
    !                  exp( -((x - x_centre - u_vel*t_tot)/half_width_x)**2 &
    !                       -((y - y_centre - v_vel*t_tot)/half_width_y)**2 )
    !   where ampl(z) = max(perturbation_height - z, 0)/perturbation_scale
    do i = timestep_start, timestep_end
      t_tot = i*dt
      call invoke( name = "Propagate perturbation",  &
                   prop_perturbation_kernel_type(perturbation, chi, t_tot) )
    end do
    !---------------------------------------------------------------------------

    !---------------------------------------------------------------------------
    ! TO COMPLETE: Check the min/max values the perturbation field using
    ! 'log_minmax' function (value limits should be the same as for the initial
    ! signal if it is still in the computational domain)
    call perturbation%log_minmax(LOG_LEVEL_INFO, perturbation%name)
    !---------------------------------------------------------------------------

    !---------------------------------------------------------------------------
    ! TO COMPLETE: Output coordinate and initial perturbation fields at the
    ! final timestep (timestep_end)
    call write_diagnostic_alg(chi_map, perturbation, timestep_end)
    !---------------------------------------------------------------------------

  end subroutine example3_alg_step

end module example3_alg_mod
