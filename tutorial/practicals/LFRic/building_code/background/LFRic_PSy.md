# LFRic PSy

[*PSy layer in LFRic in PSyclone documentation*](
https://psyclone.readthedocs.io/en/stable/dynamo0p3.html#psy-layer)

## What PSy layer does

As said in the [*What algorithms do* section](
LFRic_algorithm.md#what-algorithms-do), LFRic algorithms perform
mathematical operations on LFRic data objects and pass them as
arguments to kernel and built-in calls in `invoke`s. As said in the
[*What kernels do* section](LFRic_kernel.md#what-kernels-do), LFRic
kernels perform mathematical operations on a subset of data points
of these objects.

In the *Parallel Systems* or, in short, [PSy layer](
https://psyclone.readthedocs.io/en/stable/psy_layer.html) PSyclone
generates calls to the accessor classes for the LFRic data objects
passed from the algorithm layer, referred to as `<class_name>_proxy`
(e.g. `field_proxy`) and accesses the object data by dereferencing
the object proxies. The data and other required information is then
passed to kernels as illustrated in the
[*Kernel subroutine* section](LFRic_kernel.md#kernel-subroutine).

PSyclone also generates code for distributed and shared memory
support, however this is not utilised in this tutorial as explained
in the main [README document](../README.md). The below examples of
generated code for kernel and built-in calls are purely serial.

## Generated code to support kernel calls

As illustrated in the [*`invoke` calls* section](
LFRic_algorithm.md#invoke-calls) of algorithm introduction,
the `invoke` call from the completed algorithm in the
[simple kernels example, solutions of Part 1](
../1_simple_kernels/solutions/part1/simple_kernels_alg_mod.x90)

```fortran
    call invoke( setval_field_w0_kernel_type(field_w0, scalar_w0) )
```

translates to this PSy-layer subroutine call

```fortran
    CALL invoke_0_setval_field_w0_kernel_type(field_w0, scalar_w0)
```

in the generated `simple_kernels_alg_mod.f90` file (not kept in the repository).

The generated `invoke_0_setval_field_w0_kernel_type` subroutine code
is located in the `simple_kernels_alg_mod_psy.f90` file (also not kept in the
repository).

There is a generated declaration and a call to the `field_w0` proxy
```fortran
      TYPE(field_proxy_type) field_w0_proxy
      ...
      !
      ! Initialise field and/or operator proxies
      !
      field_w0_proxy = field_w0%get_proxy()
```

as well as generated declarations and dereferencing assignments to access
the proxy data required for the full kernel call argument list (see
[*Kernel subroutine* section](LFRic_kernel.md#kernel-subroutine)).

```fortran
      INTEGER(KIND=i_def) nlayers
      ...
      INTEGER(KIND=i_def), pointer :: map_w0(:,:) => null()
      INTEGER(KIND=i_def) ndf_w0, undf_w0
      ...
      !
      ! Initialise number of layers
      !
      nlayers = field_w0_proxy%vspace%get_nlayers()
      !
      ! Look-up dofmaps for each function space
      !
      map_w0 => field_w0_proxy%vspace%get_whole_dofmap()
      !
      ! Initialise number of DoFs for w0
      !
      ndf_w0 = field_w0_proxy%vspace%get_ndf()
      undf_w0 = field_w0_proxy%vspace%get_undf()
```

Finally, there is a generated call to `setval_field_w0_code` in the
`setval_field_w0_kernel_mod` with the complete argument list
```fortran
      !
      ! Call our kernels
      !
      DO cell=1,field_w0_proxy%vspace%get_ncell()
        !
        CALL setval_field_w0_code(nlayers, field_w0_proxy%data, &
             scalar_w0, ndf_w0, undf_w0, map_w0(:,cell))
      END DO
```

with the same argument order as in the [completed kernel example](
../1_simple_kernels/solutions/part1/setval_field_w0_kernel_mod.f90)
provided in the [first example, solutions of Part 1](
../1_simple_kernels/solutions/part1) (generated by running `genkernelstub`).

The above kernel call code call illustrates how `iterates_over = CELLS`
metadata in the [`setval_field_w0_kernel_mod.f90`](
../1_simple_kernels/solutions/part1/setval_field_w0_kernel_mod.f90)
translates to a **loop over cells** (`cell` loop counter) in the PSy layer.

---
**NOTE**

LFRic coding standards mandate lower-case for all source including
Fortran keywords and this holds for all code located in the
[LFRic repository](LFRic_intro.md#lfric-repository-structure). The
generated PSyclone Fortran code capitalises keywords for better
readability (not kept in the LFRic repository).

---

## Generated code to support built-in calls

As illustrated in the [*`invoke` calls* section](
LFRic_algorithm.md#invoke-calls) of algorithm introduction,
the `invoke` call from the completed algorithm in the
[built-ins example solutions](../2_built_ins/solutions/builtins_alg_mod.x90)

```fortran
    call invoke( name = "Builtins on W0 and W3 fields",              &
                 ...
                 X_plus_Y(field_out_w0, field1_in_w0, field2_in_w0), &
                 ... )
```

translates to this PSy-layer subroutine call

```fortran
    CALL invoke_builtins_on_w0_and_w3_fields(field_out_w0, field_out_w3, &
         field1_in_w0, field2_in_w0, field1_in_w3, field2_in_w3)
```

in the generated `builtins_alg_mod.f90` file (not kept in the repository).

The generated `invoke_builtins_on_w0_and_w3_fields` subroutine code
is located in the `builtins_alg_mod_psy.f90` file (also not kept in the
repository).

As for a kernel call there are, amongst others, generated declarations and
calls to the `field_out_w0`, `field1_in_w0` and `field2_in_w0` proxies

```fortran
      TYPE(field_proxy_type) field_out_w0_proxy, field_out_w3_proxy, &
                             field1_in_w0_proxy, field2_in_w0_proxy, &
                             field1_in_w3_proxy, field2_in_w3_proxy
      ...
      !
      ! Initialise field and/or operator proxies
      !
      field_out_w0_proxy = field_out_w0%get_proxy()
      ...
      field1_in_w0_proxy = field1_in_w0%get_proxy()
      field2_in_w0_proxy = field2_in_w0%get_proxy()
```

and generated declarations and dereferencing assignments to access
the proxy data

```fortran
      INTEGER(KIND=i_def) undf_aspc1_field_out_w0, undf_aspc1_field_out_w3, &
                          undf_aspc1_field1_in_w0, undf_aspc1_field2_in_w0, &
                          undf_aspc1_field1_in_w3, undf_aspc1_field2_in_w3
      ...
      !
      ! Initialise number of DoFs for aspc1_field_out_w0
      !
      undf_aspc1_field_out_w0 = field_out_w0_proxy%vspace%get_undf()
      ...
      ! Initialise number of DoFs for aspc1_field1_in_w0
      !
      undf_aspc1_field1_in_w0 = field1_in_w0_proxy%vspace%get_undf()
      !
      ! Initialise number of DoFs for aspc1_field2_in_w0
      !
      undf_aspc1_field2_in_w0 = field2_in_w0_proxy%vspace%get_undf()
```

Unlike the PSy-layer kernel code calls, the generated code is a direct
representation of the mathematical operation that a built-in performs
(in this case, `field_out_w0 = field1_out_w0 + field2_out_w0`)

```fortran
      !
      ! Call our kernels
      !
      ...
      DO df=1,undf_aspc1_field_out_w0
        field_out_w0_proxy%data(df) = field1_in_w0_proxy%data(df) + &
                                      field2_in_w0_proxy%data(df)
      END DO
```

(for more information on built-ins look into the
[*Quick intro to built-ins* section](
../2_built_ins/README.md#quick-intro-to-built-ins)).

The above built-in code call illustrates how `iterates_over = DOFS`
metadata in the definition of `X_plus_Y_code` translates to a
**loop over DoFs** (`df` loop counter) in the PSy layer.

---
**NOTE**

`aspc1` in the name of field data comes from `ANY_SPACE_1`, the
PSyclone [LFRic (Dynamo 0.3) API](
https://psyclone.readthedocs.io/en/stable/dynamo0p3.html) identifier for
the generic function space metadata used in the built-ins definitions (see
[*Supported Function Spaces* section](
https://psyclone.readthedocs.io/en/stable/dynamo0p3.html#dynamo0-3-function-space)
for more information).

---
