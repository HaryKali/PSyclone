program adj_test
  use tl_hydrostatic_kernel_mod, only : tl_hydrostatic_code
  use tl_hydrostatic_kernel_mod_adj, only : tl_hydrostatic_code_adj
  use constants_mod, only : r_def
  ! Begin eg17
  USE global_mesh_base_mod, ONLY: global_mesh_base_type
  USE mesh_mod, ONLY: mesh_type, PLANE
  USE partition_mod, ONLY: partition_type, partitioner_planar, partitioner_interface
  USE extrusion_mod, ONLY: uniform_extrusion_type
  USE function_space_mod, ONLY: function_space_type
  USE fs_continuity_mod, ONLY: W0, W1, W2, W2V, W2H, W3
  USE field_mod, ONLY: field_type
  USE constants_mod, ONLY: r_def, i_def
  USE log_mod, ONLY: LOG_LEVEL_ALWAYS
  IMPLICIT NONE
  TYPE(global_mesh_base_type), TARGET :: global_mesh
  CLASS(global_mesh_base_type), POINTER :: global_mesh_ptr
  TYPE(partition_type) :: partition
  TYPE(mesh_type), TARGET :: mesh
  TYPE(uniform_extrusion_type), TARGET :: extrusion
  TYPE(uniform_extrusion_type), POINTER :: extrusion_ptr
  TYPE(function_space_type), TARGET :: vector_space
  TYPE(function_space_type), POINTER :: vector_space_ptr
  PROCEDURE(partitioner_interface), POINTER :: partitioner_ptr
  TYPE(field_type) :: field1, field1_input, field2, field2_input
  INTEGER(KIND = i_def) :: lfric_fs = W0
  INTEGER(KIND = i_def) :: element_order = 1
  INTEGER(KIND = i_def) :: ndata_sz
! End of eg17
  real(kind=r_def), parameter :: overall_tolerance = 1500.0_r_def
  real(kind=r_def) :: inner1
  real(kind=r_def) :: inner2
  integer :: nlayers
  integer :: nlayers_input
  real(kind=r_def) :: ascalar
  real(kind=r_def) :: ascalar_input
  real(kind=r_def) :: MachineTol
  real(kind=r_def) :: relative_diff

  global_mesh = global_mesh_base_type()
  global_mesh_ptr => global_mesh
  partitioner_ptr => partitioner_planar
  partition = partition_type(global_mesh_ptr, partitioner_ptr, 1, 1, 0, 0, 1)
  extrusion = uniform_extrusion_type(0.0_r_def, 100.0_r_def, 5)
  extrusion_ptr => extrusion
  mesh = mesh_type(global_mesh_ptr, partition, extrusion_ptr)
  WRITE(*, *) "Mesh has", mesh % get_nlayers(), "layers."
  ndata_sz = 1
  vector_space = function_space_type(mesh, element_order, lfric_fs, ndata_sz)
  vector_space_ptr => vector_space
  CALL field1 % initialise(vector_space = vector_space_ptr, name = "field1")
  CALL field2 % initialise(vector_space = vector_space_ptr, name = "field2")

  call random_number(ascalar)
  ascalar_input = ascalar
  call invoke( setval_random(field1), &
               setval_random(field2), &
               setval_X(field1_input, field1), &
               setval_X(field2_input, field1), &
               ! Call the tangent-linear kernel
               tl_testkern_type(ascalar, field1, field2), &
               X_innerproduct_X(rinner1, field1), &
               X_innerproduct_X(rinner2, field2) )
  inner1 = ascalar*ascalar + rinner1 + rinner2
  ! Call the adjoint kernel
  call invoke( adj_testkern_type(ascalar, field1, field2), &
               X_innerproduct_Y(rinner1, field1_input, field1), &
               X_innerproduct_Y(rinner2, field2_input, field2) )
  inner2 = ascalar_input*ascalar + rinner1 + rinner2

  ! Test the inner-product values for equality, allowing for the precision of the active variables
  MachineTol = SPACING(MAX(ABS(inner1), ABS(inner2)))
  relative_diff = ABS(inner1 - inner2) / MachineTol
  if (relative_diff < overall_tolerance) then
    WRITE(*, *) 'Test of adjoint of ''tl_hydrostatic_code'' PASSED: ', inner1, inner2, relative_diff
  else
    WRITE(*, *) 'Test of adjoint of ''tl_hydrostatic_code'' FAILED: ', inner1, inner2, relative_diff
  end if

end program adj_test
