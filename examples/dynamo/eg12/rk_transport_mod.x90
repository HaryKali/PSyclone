!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-------------------------------------------------------------------------------
! LICENCE.original is available from the Met Office Science Repository Service:
! https://code.metoffice.gov.uk/trac/lfric/browser/LFRic/trunk/LICENCE.original
! ------------------------------------------------------------------------------
! BSD 3-Clause License
!
! Modifications copyright (c) 2017-2019, Science and Technology Facilities Council
! All rights reserved.
!
! Redistribution and use in source and binary forms, with or without
! modification, are permitted provided that the following conditions are met:
!
! * Redistributions of source code must retain the above copyright notice, this
!   list of conditions and the following disclaimer.
!
! * Redistributions in binary form must reproduce the above copyright notice,
!   this list of conditions and the following disclaimer in the documentation
!   and/or other materials provided with the distribution.
!
! * Neither the name of the copyright holder nor the names of its
!   contributors may be used to endorse or promote products derived from
!   this software without specific prior written permission.
!
! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
! ------------------------------------------------------------------------------
! Modified by I Kavcic, Met Office
!-------------------------------------------------------------------------------

!>@brief A Runge-Kutta time-discretisation of the transport equation
!>@details An algorithm for timstepping the 3D transport equation using a
!>         multistage explicit Runge-Kutta algorithm.
module rk_transport_mod

  use constants_mod,                     only: r_def, i_def
  use log_mod,                           only: log_event,         &
                                               log_scratch_space, &
                                               LOG_LEVEL_INFO,    &
                                               LOG_LEVEL_TRACE

  ! Configuration and restart/checkpoint options
  use finite_element_config_mod,         only: element_order, supg
  use restart_control_mod,               only: restart_type
  use timestepping_config_mod,           only: dt
  use runge_kutta_init_mod,              only: num_rk_stage, ak
  use runtime_constants_mod,             only: get_mass_matrix,                &
                                               get_mass_matrix_diagonal,       &
                                               get_inverse_lumped_mass_matrix, &
                                               get_qr,                         &
                                               w2_id, w3_id, w3inv_id,         &
                                               wt_id, theta_space_id,          &
                                               get_coordinates

  use transport_config_mod,              only: operators,              &
                                               fv_flux_order,          &
                                               fv_advective_order,     &
                                               transport_operators_fv, &
                                               transport_operators_fem

  ! PsyKAl-lite kernels
  use psykal_lite_mod,                   only: invoke_sample_poly_flux, &
                                               invoke_sample_poly_adv
  ! PsyKAl PSYClone kernels
  use rrho_kernel_mod,                   only: rrho_kernel_type
  use flux_rhs_kernel_mod,               only: flux_rhs_kernel_type
  use enforce_bc_kernel_mod,             only: enforce_bc_kernel_type
  use rtheta_kernel_mod,                 only: rtheta_kernel_type
  use rtheta_supg_kernel_mod,            only: rtheta_supg_kernel_type


  use sample_poly_flux_kernel_mod,       only: sample_poly_flux_init, &
                                               sample_poly_flux_final
  use sample_poly_adv_kernel_mod,        only: sample_poly_adv_init,  &
                                               sample_poly_adv_final

  ! Derived Types
  use field_mod,                         only: field_type
  use function_space_mod,                only: function_space_type
  use quadrature_xyoz_mod,               only: quadrature_xyoz_type
  use operator_mod,                      only: operator_type

  ! Algorithms
  use mass_matrix_solver_alg_mod,        only: mass_matrix_solver_alg
  ! Log
  use log_mod,                           only: log_event,         &
                                               LOG_LEVEL_ERROR
  use output_config_mod,                 only: subroutine_timers 
  use timer_mod,                         only: timer
  implicit none

  private

  ! 'State' items that need to be created once but used every step
  type( field_type )              :: rho_n, r_u, r_rho, rho_inc, mass_flux, &
                                     theta_n, r_theta, theta_inc
  type( field_type ), allocatable :: rr_prediction(:), rt_prediction(:)
  type( field_type )              :: mt_lumped
  type( field_type )              :: rho0, theta0
  type( field_type )              :: ones

  integer(i_def) :: flux_stencil_extent, &
                    advective_stencil_extent

  public :: rk_transport_init
  public :: rk_transport_step
  public :: rk_transport_final

contains

  !> @brief Init routine for rk transport timestepping algorithm
  !> @details Rho and u fields are initialised before
  !>          this algorithm is called. State items are created,
  !> @param[in]    mesh_id Mesh id of mesh on which the model runs
  !> @param[in]    u 3D wind field
  !> @param[inout] rho Density like field
  !> @param[inout] theta Temperature like field
  subroutine rk_transport_init( mesh_id, u, rho, theta)
    use mesh_mod,                          only: mesh_type
    use mesh_collection_mod,               only: mesh_collection
    use matrix_vector_kernel_mod,          only: matrix_vector_kernel_type
    implicit none

    ! Mesh id
    integer(i_def),  intent(in) :: mesh_id
    ! Prognostic fields
    type( field_type ), intent( in ) :: u, rho, theta

    type(function_space_type), pointer :: u_fs     => null()
    type(function_space_type), pointer :: rho_fs   => null()
    type(function_space_type), pointer :: theta_fs => null()
    type( mesh_type ),         pointer :: mesh     => null()

    ! Timestepping variables
    integer :: stage
    type(operator_type), pointer :: mm_wt => null()

    if ( subroutine_timers ) call timer('rk_transport_alg')

    allocate ( rr_prediction(num_rk_stage) )
    allocate ( rt_prediction(num_rk_stage) )

    !=== Section 1: Create field objects =====================================!
    ! Local fields
    u_fs     => u%get_function_space()
    rho_fs   => rho%get_function_space()
    theta_fs => theta%get_function_space()

    rho_n        = field_type( vector_space = rho_fs )
    r_rho        = field_type( vector_space = rho_fs )
    rho_inc      = field_type( vector_space = rho_fs )
    r_u          = field_type( vector_space = u_fs )
    mass_flux    = field_type( vector_space = u_fs )
    theta_n      = field_type( vector_space = theta_fs )
    r_theta      = field_type( vector_space = theta_fs )
    theta_inc    = field_type( vector_space = theta_fs )


    do stage = 1,num_rk_stage
      rr_prediction(stage) = field_type( vector_space = rho_fs )
      rt_prediction(stage) = field_type( vector_space = theta_fs )
    end do

    call invoke( setval_c(mass_flux, 0.0_r_def) )

    if ( operators == transport_operators_fv ) then
      if ( element_order == 0 ) then
        mesh => mesh_collection%get_mesh( mesh_id )
        call sample_poly_flux_init(fv_flux_order, mesh%get_nlayers())
        call sample_poly_adv_init (fv_advective_order, mesh%get_nlayers())
        ! Compute stencil extents
        flux_stencil_extent      = int(real(fv_flux_order+1)/2.0,i_def)
        advective_stencil_extent = int(real(fv_advective_order+1)/2.0,i_def)
      else
        call log_event( "Gungho: subgrid mappings needed for FV MoL with high order elements", LOG_LEVEL_ERROR )
      end if
      mm_wt => get_mass_matrix(wt_id)
      ones  = field_type( vector_space = theta_fs )
      mt_lumped  = field_type( vector_space = theta_fs )
      call invoke( name = "Compute mt_lumped",     &
                   setval_c(ones,      1.0_r_def), &
                   setval_c(mt_lumped, 0.0_r_def), &
                   matrix_vector_kernel_type(mt_lumped, ones, mm_wt) )
    else
      ones  = field_type( vector_space = rho_fs)
      call invoke( setval_c(ones, 1.0_r_def) )
    end if

    ! Store initial values for computing errors
    rho0   = rho
    theta0 = theta

    nullify( mm_wt, mesh, u_fs, rho_fs, theta_fs )

    if ( subroutine_timers ) call timer('rk_transport_alg')

  end subroutine rk_transport_init


  !> @brief Final routine for rk transport timestepping algorithm

  !> @param[in] rho Density
  !> @param[in] theta Potential temperature field
  subroutine rk_transport_final( rho, theta)

    use matrix_vector_kernel_mod, only: matrix_vector_kernel_type

    implicit none

    type( field_type ), intent(in) :: rho, theta
 
    type( field_type )                 :: drho, dtheta, l2_rho, l2_theta
    type(function_space_type), pointer :: rho_fs   => null()
    type(function_space_type), pointer :: theta_fs => null()
    type(operator_type),       pointer :: mm_wt => null(), mm_w3 => null()
    real(kind=r_def)                   :: l2_rho_scalar, l2_theta_scalar

    ! Compute L errors
    rho_fs   => rho%get_function_space()
    theta_fs =>  theta%get_function_space()

    drho   = field_type( vector_space = rho_fs )
    dtheta = field_type( vector_space = theta_fs )
    call invoke( X_minus_Y(drho,   rho,   rho0  ), &
                 X_minus_Y(dtheta, theta, theta0) )

    ! L2 error
    mm_w3 => get_mass_matrix(w3_id)
    mm_wt => get_mass_matrix(theta_space_id)
    l2_theta = field_type( vector_space = theta_fs )
    l2_rho   = field_type( vector_space = rho_fs )
    call invoke( name = "Compute L2 error for theta and rho",        &
    ! Initialise fields
                 setval_c(l2_theta, 0.0_r_def),                      &
                 setval_c(l2_rho,   0.0_r_def),                      &
    ! Matrix-vector multiplication
                 matrix_vector_kernel_type(l2_theta, dtheta, mm_wt), &
                 matrix_vector_kernel_type(l2_rho,   drho,   mm_w3), &
    ! Compute L2 error for theta
                 X_innerproduct_Y(l2_theta_scalar, dtheta, l2_theta), &
    ! Compute L2 error for rho
                 X_innerproduct_Y(l2_rho_scalar, drho, l2_rho) )

    ! Write out L2 errors
    write( log_scratch_space, '(A, E15.8)' ) "L2 theta = ", sqrt(l2_theta_scalar)
    call log_event( log_scratch_space, LOG_LEVEL_info )
    write( log_scratch_space, '(A, E15.8)' ) "L2 rho   = ", sqrt(l2_rho_scalar)
    call log_event( log_scratch_space, LOG_LEVEL_info )

    call sample_poly_flux_final()
    call sample_poly_adv_final()

    nullify( mm_wt, mm_w3, rho_fs, theta_fs )

    if ( subroutine_timers ) call timer('rk_transport_alg')

  end subroutine rk_transport_final

end module rk_transport_mod
