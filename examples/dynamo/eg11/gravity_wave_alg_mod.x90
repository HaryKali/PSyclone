!-------------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-------------------------------------------------------------------------------
! LICENCE.original is available from the Met Office Science Repository Service:
! https://code.metoffice.gov.uk/trac/lfric/browser/LFRic/trunk/LICENCE.original
! ------------------------------------------------------------------------------
! BSD 3-Clause License
!
! Modifications copyright (c) 2017-2018, Science and Technology Facilities Council
! All rights reserved.
!
! Redistribution and use in source and binary forms, with or without
! modification, are permitted provided that the following conditions are met:
!
! * Redistributions of source code must retain the above copyright notice, this
!   list of conditions and the following disclaimer.
!
! * Redistributions in binary form must reproduce the above copyright notice,
!   this list of conditions and the following disclaimer in the documentation
!   and/or other materials provided with the distribution.
!
! * Neither the name of the copyright holder nor the names of its
!   contributors may be used to endorse or promote products derived from
!   this software without specific prior written permission.
!
! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
! ------------------------------------------------------------------------------
! Modified by I Kavcic, Met Office
!-------------------------------------------------------------------------------

!>@brief A two time-level iterative time-discretisation of the linear 
!>       gravity wave equations
module gravity_wave_alg_mod

  use constants_mod,                  only: i_def,r_def
  use log_mod,                        only: log_event,         &
                                            log_scratch_space, &
                                            LOG_LEVEL_INFO,    &
                                            LOG_LEVEL_ERROR,   &
                                            LOG_LEVEL_TRACE

  ! Configuration options
  use finite_element_config_mod,      only: element_order
  use timestepping_config_mod,        only: dt, alpha 
  use runtime_constants_mod,          only: get_div, &
                                            get_mass_matrix, &
                                            w3inv_id
  use initial_temperature_config_mod, only: bvf_square  
  use gravity_wave_constants_config_mod,only: cs_square

  ! Derived Types
  use field_mod,                      only: field_type
  use field_vector_mod,               only: field_vector_type
  use derived_config_mod,             only: bundle_size
  use function_space_mod,             only: function_space_type
  use operator_mod,                   only: operator_type

  ! Algorithms
  use gw_mixed_operator_alg_mod,      only: gw_mixed_operator_type
  use gw_mixed_schur_preconditioner_alg_mod, &
                                      only: gw_mixed_schur_preconditioner_type
  use gw_mixed_diag_preconditioner_alg_mod, &
                                      only: gw_mixed_diag_preconditioner_type
  use gw_pressure_operator_alg_mod,   only: gw_pressure_operator_type
  use gw_pressure_precon_alg_mod,     only: gw_pressure_preconditioner_type
  use gw_null_preconditioner_alg_mod, only: gw_null_preconditioner_type

  ! preconditioner and solver
  use preconditioner_mod,             only: abstract_preconditioner_type
  use iterative_solver_mod,           only: abstract_iterative_solver_type, &
                                            bicgstab_type, &
                                            gmres_type, &
                                            conjugate_gradient_type

  use field_indices_mod,              only: igw_u, igw_p, igw_b

  use output_config_mod,              only: subroutine_timers 
  use timer_mod,                      only: timer

  implicit none

  private

  ! 'State' items private to the algorithm that need to be 
  !  created once but used every step
  type( field_vector_type ) :: state, state_n, rhs_n
  type( field_type )        :: rhs_p
  type(operator_type)       :: Q

  ! Operator, preconditioner and iterative solver for mixed problem
  type( gw_mixed_operator_type)                       :: gw_mixed_operator
  class( abstract_preconditioner_type),   allocatable :: gw_mixed_preconditioner
  class( abstract_iterative_solver_type), allocatable :: gw_mixed_solver
  
  !> Absolute solver tolerance (mixed solver)
  real(kind=r_def), parameter :: gw_mixed_solver_a_tol = 1.E-12

  !> Operator, preconditioner and iterative solver for
  !> Helmholtz (pressure) problem
  type( gw_pressure_operator_type )                    :: gw_pressure_operator
  class( abstract_preconditioner_type ),   allocatable :: gw_pressure_preconditioner
  class( abstract_iterative_solver_type ), allocatable :: gw_pressure_solver
  
  !> Absolute solver tolerance (pressure solver)
  real(kind=r_def), parameter :: gw_pressure_solver_a_tol = 1.E-12

  public :: gravity_wave_alg_init
  public :: gravity_wave_alg_final
  public :: gravity_wave_alg_step

contains
!=============================================================================!
  !> @details Initialisation procedure for the timestepping algorithm
  !>          Initialises various internal fields
  !> @param[in]    mesh_id ID of mesh object on which the model runs
  !> @param[inout] wind  The 3D wind field
  !> @param[inout] pressure The pressure field
  !> @param[inout] buoyancy The buoyancy field
  subroutine gravity_wave_alg_init( mesh_id, wind, pressure, buoyancy)
    use quadrature_xyoz_mod,           only: quadrature_xyoz_type
    use quadrature_rule_gaussian_mod,  only: quadrature_rule_gaussian_type
    use compute_q_operator_kernel_mod, only: compute_q_operator_type, &
                                             compute_q_operator_init
    use mesh_mod,                      only: mesh_type
    use mesh_collection_mod,           only: mesh_collection
    use mixed_solver_config_mod,       only: si_maximum_iterations,                      &
                                             si_tolerance,                               &
                                             si_method,                                  &
                                             mixed_gcrk => gcrk,                         &
                                             mixed_solver_si_method_cg,                  &
                                             mixed_solver_si_method_bicgstab,            &
                                             mixed_solver_si_method_gmres,               &
                                             si_preconditioner,                          &
                                             mixed_solver_si_preconditioner_pressure,    &
                                             mixed_solver_si_preconditioner_diagonal,    &
                                             mixed_solver_si_preconditioner_none

    use helmholtz_solver_config_mod,   only: si_pressure_maximum_iterations,             &
                                             helmholtz_gcrk => gcrk,                     &
                                             si_pressure_tolerance,                      &
                                             helmholtz_method => method,                 &
                                             helmholtz_solver_method_cg,                 &
                                             helmholtz_solver_method_bicgstab,           &
                                             helmholtz_solver_method_gmres,              &
                                             helmholtz_preconditioner => preconditioner, &
                                             helmholtz_solver_preconditioner_none,       &
                                             helmholtz_solver_preconditioner_tridiagonal
    implicit none

    ! Mesh
    integer(i_def), intent(in) :: mesh_id 

    ! Prognostic fields    
    type( field_type ), intent( inout ) :: wind, pressure, buoyancy

    type(function_space_type), pointer  :: u_fs => null()
    type(function_space_type), pointer  :: p_fs => null()
    type(function_space_type), pointer  :: b_fs => null()
    type(quadrature_xyoz_type)          :: qr
    type(quadrature_rule_gaussian_type) :: quadrature_rule

    real(kind=r_def), allocatable       :: dz(:)
    type(mesh_type),           pointer  :: mesh => null()
    integer(kind=i_def)                 :: nlayers

    !=== Create internal state field arrays ================================!
    state   = field_vector_type(bundle_size)
    state_n = field_vector_type(bundle_size)
    rhs_n   = field_vector_type(bundle_size)

    !=== Initialise internal state field objects =============================!
    u_fs => wind%get_function_space() 
    p_fs => pressure%get_function_space()
    b_fs => buoyancy%get_function_space()
    
    call state%import_field(wind,     igw_u)
    call state%import_field(pressure, igw_p)
    call state%import_field(buoyancy, igw_b)

    state_n = state
    rhs_n = state

    rhs_p =  field_type( vector_space = p_fs )

    ! Create Q operator
    Q = operator_type( u_fs, b_fs)
    qr = quadrature_xyoz_type(element_order+2, quadrature_rule)
    mesh => mesh_collection%get_mesh( mesh_id )
    nlayers = mesh%get_nlayers()
    allocate ( dz(nlayers) )
    call mesh%get_dz(dz)
    call compute_q_operator_init(dz, nlayers)
    call invoke( compute_q_operator_type(Q, qr) )
    
    ! *** Allocate polymorphic solver- and preconditioner objects ***

    ! Allocate pressure solver of correct type
    if (helmholtz_method == HELMHOLTZ_SOLVER_METHOD_BICGSTAB) then
       allocate ( bicgstab_type :: gw_pressure_solver )
    else if (helmholtz_method == HELMHOLTZ_SOLVER_METHOD_CG) then
       allocate ( conjugate_gradient_type :: gw_pressure_solver )
    else if (helmholtz_method == HELMHOLTZ_SOLVER_METHOD_GMRES) then
       allocate ( gmres_type :: gw_pressure_solver )
    else
       call log_event("Unknown pressure solver specified",LOG_LEVEL_ERROR)
    end if

    ! Allocate pressure preconditioner preconditioner of correct type
    if (helmholtz_preconditioner == HELMHOLTZ_SOLVER_PRECONDITIONER_NONE) then
       allocate ( gw_null_preconditioner_type :: gw_pressure_preconditioner)
    else if (helmholtz_preconditioner == HELMHOLTZ_SOLVER_PRECONDITIONER_TRIDIAGONAL) then
       allocate ( gw_pressure_preconditioner_type :: gw_pressure_preconditioner)
    else
       call log_event( "Unknown pressure preconditioner specified", &
                       LOG_LEVEL_ERROR)
    end if

    ! Allocate mixed preconditioner of correct type
    if (si_preconditioner == MIXED_SOLVER_SI_PRECONDITIONER_PRESSURE) then
       allocate ( gw_mixed_schur_preconditioner_type :: gw_mixed_preconditioner)
    else if (si_preconditioner == MIXED_SOLVER_SI_PRECONDITIONER_DIAGONAL) then
       allocate ( gw_mixed_diag_preconditioner_type :: gw_mixed_preconditioner)
    else if (si_preconditioner == MIXED_SOLVER_SI_PRECONDITIONER_NONE) then
       allocate ( gw_null_preconditioner_type :: gw_mixed_preconditioner)
    else
       call log_event("Unknown mixed preconditioner specified",LOG_LEVEL_ERROR)
    end if

    ! Allocate mixed solver of correct type
    if (si_method == MIXED_SOLVER_SI_METHOD_BICGSTAB) then
      allocate ( bicgstab_type :: gw_mixed_solver )
    else if (si_method == MIXED_SOLVER_SI_METHOD_CG) then
      allocate ( conjugate_gradient_type :: gw_mixed_solver )
    else if (si_method == MIXED_SOLVER_SI_METHOD_GMRES) then
      allocate ( gmres_type :: gw_mixed_solver )
    else
       call log_event("Unknown mixed solver specified",LOG_LEVEL_ERROR)
    end if

    ! *** Construct solver-, preconditioner- and operator-objects

    ! Construct Helmholtz operator and preconditioner
    gw_pressure_operator = gw_pressure_operator_type(state)

    ! Construct pressure preconditioner
    select type(gw_pressure_preconditioner)
    type is ( gw_null_preconditioner_type )        
       ! Null preconditioner
       gw_pressure_preconditioner = gw_null_preconditioner_type()
    type is ( gw_pressure_preconditioner_type )        
       ! Vertical preconditioner
       gw_pressure_preconditioner = gw_pressure_preconditioner_type()
    class default
       call log_event( "Can not initialise pressure preconditioner", &
                       LOG_LEVEL_ERROR )
    end select

    ! Construct pressure solver
    select type(gw_pressure_solver)
    type is ( conjugate_gradient_type )        
       ! BiCGStab solver
       gw_pressure_solver = conjugate_gradient_type( gw_pressure_operator,           &
                                                     gw_pressure_preconditioner,     &
                                                     si_pressure_tolerance,          &
                                                     gw_pressure_solver_a_tol,       &
                                                     si_pressure_maximum_iterations)
    type is ( bicgstab_type )        
       ! BiCGStab solver
       gw_pressure_solver = bicgstab_type( gw_pressure_operator,           &
                                           gw_pressure_preconditioner,     &
                                           si_pressure_tolerance,          &
                                           gw_pressure_solver_a_tol,       &
                                           si_pressure_maximum_iterations)
    type is ( gmres_type )        
       ! GMRES solver
       gw_pressure_solver = gmres_type( gw_pressure_operator,           &
                                        gw_pressure_preconditioner,     &
                                        helmholtz_gcrk,                 &
                                        si_pressure_tolerance,          &
                                        gw_pressure_solver_a_tol,       &
                                        si_pressure_maximum_iterations)

    class default
       call log_event("Can not initialise pressure solver",LOG_LEVEL_ERROR)
    end select

    ! Set up mixed operator
    gw_mixed_operator = gw_mixed_operator_type(state)
    
    ! Set up mixed preconditioner
    select type(gw_mixed_preconditioner)
    type is ( gw_mixed_schur_preconditioner_type )
       ! Schur-complement preconditioner
       gw_mixed_preconditioner = &
           gw_mixed_schur_preconditioner_type(state, &
                                              gw_pressure_operator%get_Hb_lumped_inv(), &
                                              gw_pressure_solver)
    type is ( gw_mixed_diag_preconditioner_type )
       ! Diagonal preconditioner
       gw_mixed_preconditioner = gw_mixed_diag_preconditioner_type(state)
    type is ( gw_null_preconditioner_type )
       ! Null preconditioner
       gw_mixed_preconditioner = gw_null_preconditioner_type()
    class default
       call log_event("Can not initialise mixed preconditioner", &
                      LOG_LEVEL_ERROR)
    end select
    select type(gw_mixed_solver) 
    type is ( conjugate_gradient_type )        
       gw_mixed_solver = conjugate_gradient_type( gw_mixed_operator,       &
                                                  gw_mixed_preconditioner, &
                                                  si_tolerance,            &
                                                  gw_mixed_solver_a_tol,   &
                                                  si_maximum_iterations)
    type is ( bicgstab_type )        
       gw_mixed_solver = bicgstab_type( gw_mixed_operator,       &
                                        gw_mixed_preconditioner, &
                                        si_tolerance,            &
                                        gw_mixed_solver_a_tol,   &
                                        si_maximum_iterations)
    type is ( gmres_type )        
       gw_mixed_solver = gmres_type( gw_mixed_operator,       &
                                     gw_mixed_preconditioner, &
                                     mixed_gcrk,              &
                                     si_tolerance,            &
                                     gw_mixed_solver_a_tol,   &
                                     si_maximum_iterations)
    class default
       call log_event("Can not initialise mixed solver",LOG_LEVEL_ERROR)
    end select

    call log_event( "Gravity Wave: initialised timestepping algorithm", LOG_LEVEL_INFO )

  end subroutine gravity_wave_alg_init

  !@brief Tidy up gravity wave algorithm module
  !>
  !@details Deallocate memory
  subroutine gravity_wave_alg_final()
    implicit none

    ! Deallocate mixed preconditioner object
    if (allocated(gw_mixed_preconditioner)) then
       deallocate(gw_mixed_preconditioner)
    end if
    ! Deallocate mixed solver object
    if (allocated(gw_mixed_solver)) then
       deallocate(gw_mixed_solver)
    end if
    ! Deallocate pressure preconditioner object
    if (allocated(gw_pressure_preconditioner)) then
       deallocate(gw_pressure_preconditioner)
    end if
    ! Deallocate pressure solver object
    if (allocated(gw_pressure_solver)) then
       deallocate(gw_pressure_solver)
    end if
  end subroutine gravity_wave_alg_final

!=============================================================================!

  !> @details An algorithm for timestepping the 3D linear  gravity wave
  !>   equations using a centred implicit method
  !>
  !> @param[inout] wind  The 3D wind field
  !> @param[inout] pressure The pressure field
  !> @param[inout] buoyancy The buoyancy field
  subroutine gravity_wave_alg_step(wind, pressure, buoyancy)

  use matrix_vector_kernel_mod,           only: matrix_vector_kernel_type
  use dg_matrix_vector_kernel_mod,        only: dg_matrix_vector_kernel_type
  use transpose_matrix_vector_kernel_mod, only: transpose_matrix_vector_kernel_type
  use enforce_bc_kernel_mod,              only: enforce_bc_kernel_type

    implicit none

    ! Prognostic fields    
    type( field_type ), intent( inout ) :: wind, pressure, buoyancy

    type(operator_type), pointer :: div    => null() 
    type(operator_type), pointer :: m3_inv => null() 

    ! Auxiliary constants to group invokes
    real(kind=r_def)             :: const1, const2

    if ( subroutine_timers ) call timer('gravity_wave_alg')
    !=== Do a single timestep ==============================================!
    div => get_div()
    m3_inv => get_mass_matrix(w3inv_id)

    call state%import_field(wind,     igw_u)
    call state%import_field(pressure, igw_p)
    call state%import_field(buoyancy, igw_b)

    state_n = state

    ! Set auxiliary constants
    const1 = -dt*cs_square
    const2 = -dt*bvf_square

    ! Compute rhs of the gravity wave system
    call invoke( setval_c(rhs_n%vector(igw_u), 0.0_r_def),                  &
                 setval_c(rhs_n%vector(igw_b), 0.0_r_def),                  &
                 transpose_matrix_vector_kernel_type(rhs_n%vector(igw_u),   &
                                                     state_n%vector(igw_p), &
                                                     div),                  &
                 matrix_vector_kernel_type          (rhs_n%vector(igw_u),   &
                                                     state_n%vector(igw_b), &
                                                     Q),                    &
                 dg_matrix_vector_kernel_type       (rhs_p,                 &
                                                     state_n%vector(igw_u), &
                                                     div),                  &
                 dg_matrix_vector_kernel_type       (rhs_n%vector(igw_p),   &
                                                     rhs_p,                 &
                                                     m3_inv),               &
                 transpose_matrix_vector_kernel_type(rhs_n%vector(igw_b),   &
                                                     state_n%vector(igw_u), &
                                                     Q),                    &
    ! Apply timestep scalings
                 inc_a_times_X(dt,     rhs_n%vector(igw_u)),                &
                 inc_a_times_X(const1, rhs_n%vector(igw_p)),                &
                 inc_a_times_X(const2, rhs_n%vector(igw_b)),                &
    ! Apply BC to wind rhs
                 enforce_bc_kernel_type(rhs_n%vector(igw_u)) )

    ! Solve mixed system
    call log_event( "Gravity Wave: mixed solve:", LOG_LEVEL_INFO )
    call gw_mixed_solver%apply(state, rhs_n)

    ! Return fields
    call state%export_field(wind,     igw_u)
    call state%export_field(pressure, igw_p)
    call state%export_field(buoyancy, igw_b)

    if ( subroutine_timers ) call timer('gravity_wave_alg')

  end subroutine gravity_wave_alg_step

end module gravity_wave_alg_mod
